package chat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.UUID;

import tuplespaces.TupleSpace;

public class ChatServer {
	
	public static final String 	CHANNELSET 		= "chs";
	public static final String 	NEXTWRITE 		= "nxw";
	public static final String 	LISTENERSET 	= "lts";
	public static final String 	SIGNALWRITE		= "sgw";
	public static final String 	SIGNALREAD 		= "sgr";
	public static final String 	MESSAGE 		= "msg";
	
	TupleSpace ts;
	
	ChannelSet chSet = new ChannelSet();
	HashMap<String, IDSet> sigwrtMap = new HashMap<String, IDSet>();
	HashMap<String, IDSet> listenerMap = new HashMap<String, IDSet>();
	
	public ChatServer(TupleSpace t, int rows, String[] channelNames) {
		ts = t;
		
		String[] tuple = ts.get(CHANNELSET, null);
		chSet.fromString(tuple[1]);
		
		for (String ch : channelNames) {
			if (chSet.add(ch, rows)) {
				ts.put(ch, NEXTWRITE, "0");
				ts.put(ch, LISTENERSET, "");
			}
		}
		ts.put(CHANNELSET, chSet.toString());
		
//		System.out.println("[S] chlist " + chSet.toString());
		
		for (String ch : chSet.getChannels()) {
			sigwrtMap.put(ch, new IDSet());
			listenerMap.put(ch, new IDSet());
		}
		
//		System.out.println("[S] a server created.");
	}

	public ChatServer(TupleSpace t) {
		ts = t;
		String[] tuple = ts.read(CHANNELSET, null);
		chSet.fromString(tuple[1]);
	}

	public String[] getChannels() {
		String[] tuple = ts.get(CHANNELSET, null);
		ChannelSet set = new ChannelSet();
		set.fromString(tuple[1]);
		
		ArrayList<String> merged = chSet.merge(set);
		for (String ch : merged) {
			sigwrtMap.put(ch, new IDSet());
			listenerMap.put(ch, new IDSet());
		}
		
		ts.put(CHANNELSET, chSet.toString());
		
		return chSet.getChannels();
	}
	
	public void writeMessage(String channel, String message) {
		String[] tuple; 
		// disable other chat servers
		tuple = ts.get(channel, NEXTWRITE, null);
		int wPos = Integer.parseInt(tuple[2]);
		int rows = chSet.getRows(channel);
		String qPos = Integer.toString(wPos % rows);
		
		// get current listener set
		tuple = ts.read(channel, LISTENERSET, null);
		IDSet listeners = listenerMap.get(channel);
		listeners.fromString(tuple[2]);

		// before overwriting message, we must wait until that message has 
		// been received by all listeners
		if(wPos < rows) {
			// write directly if no need to overwrite message
			ts.put(channel, MESSAGE, qPos, message);
//			System.out.println("[S] " + channel + ": write directly " + wPos);
		} else {
			// collect write signals generated by listeners
			IDSet sigWrts = sigwrtMap.get(channel);
			sigWrts.clear();
			
//			System.out.println("[S] " + channel + ": lsnset " + listeners.toString());
			
			while (!listeners.containedBy(sigWrts)){
				tuple = ts.get(channel, SIGNALWRITE, qPos, null);
				sigWrts.add(tuple[3]);
				
//				System.out.println("[S] " + channel + ": sigwrt " + sigWrts.toString());
			}
			
//			System.out.println("[S] " + channel + ": ready for writing " + qPos + " " + wPos);
			
			// overwriting the message
			ts.get(channel, MESSAGE, qPos, null);
			ts.put(channel, MESSAGE, qPos, message);
			
//			System.out.println("[S] " + channel + ": after writing " + qPos + " " + wPos);
		}
		
		// signal waiting listeners for reading if any
		for (String id : listeners) {
			ts.put(channel, SIGNALREAD, qPos, id);
		}
		
		// enable other chat servers
		ts.put(channel, NEXTWRITE, Integer.toString(wPos + 1));
	}

	public ChatListener openConnection(String channel) {
		
//		System.out.println("[S] " + channel + ": before openConnection");
		
		String[] tuple;
		// In order to make sure the new listener starts from the correct 
		// position, we have to disable other chat servers
		tuple = ts.get(channel, NEXTWRITE, null);
		int wPos = Integer.parseInt(tuple[2]);
		
		tuple = ts.get(channel, LISTENERSET, null);
		IDSet listeners = new IDSet();
		listeners.fromString(tuple[2]);
		
//		System.out.println("[S] " + channel + ": lsnset " + listeners.toString());
		
		int rows = chSet.getRows(channel);
		int rPos = 0;
		if (wPos >= rows)
			rPos = wPos - rows;
		String id = UUID.randomUUID().toString();
		
		// signal the new listener for reading
		for (int i = rPos; i < wPos; i++) {
			ts.put(channel, SIGNALREAD, Integer.toString(i % rows), id);
		}
		
		// update listeners list
		listeners.add(id);
		ts.put(channel, LISTENERSET, listeners.toString());
		
		// enable other chat servers
		ts.put(channel, NEXTWRITE, Integer.toString(wPos));
		
//		System.out.println("[S] " + channel + ": after openConnection");
//		System.out.println("[S] " + channel + ": listener created with " 
//						+ rows + " " + rPos + " " + id);
		
		return new ChatListener(ts, channel, rows, rPos, id);
	}
}
